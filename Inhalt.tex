\chapter{Einleitung}
\paragraph{}
Die ckc group ist ein von Christian Krentel im Jahr 1989 gegründeter IT- und Business-Consulting-Anbieter in Braunschweig. Sie gehört in dem Bereich zu den führenden Unternehmen Deutschlands. In den Standorten Braunschweig, Berlin, Darmstadt, Hamburg, Dortmund und München beschäftigt sie rund 400 Mitarbeiter\fcitetitle{Mitarbeiterzahl}.
\paragraph{}
Hauptbranchen des Unternehmens sind die Automobilindustrie samt Zulieferer sowie Banken, Versicherungen, Luft- und Raumfahrt, Retail, Transport und Logistik. Die Kernkompetenz von ckc liegt im Bereich der IT nicht nur auf der 
Softwareentwicklung, sondern zu Teilen zusätzlich auf der Managementberatung.

\section{Projektbeschreibung}
\paragraph{}
Das ”Sisyfox” Projekt wird entworfen, um für firmeninterne Events (z.B. Seminare, Konferenzen, Sommerfeste, etc.) eine Attraktion zu bieten, die nicht nur mit Spaß verbunden wird, sondern aus der sich auch ein Lernwert ergibt. 
Das Spiel stellt in einer vereinfachten Form den Mythos des Sisyphos und sein immerwährendes Scheitern gamifiziert\fcitetitle{Gamifizierung} dar. Den Mitarbeitern soll dabei der Umgang mit dem Erlebnis des Scheiterns näher gebracht werden. Außerdem soll diese Gamifizierung zu einer Motivationssteigerung führen.
\paragraph{}
Der Charakter im Spiel wird mit einem Aufbau, auf dem ein 1.20m großer Ball als Steuerkugel\footnote{Wie in einem Kugellager.} befestigt ist, vom Spieler gelenkt. Dafür steht der Aufbau vor dem Spieler auf dem Boden. 
Die Kugel kann durch den Aufbau mit den Händen auf der Stelle bewegt werden. Die Sensordaten des Aufbaues werden direkt an den Computer übermittelt und müssen in der Steuerung umgesetzt werden. 
\paragraph{}
Die Aufgabe in dem Projekt besteht darin, die Steuerung für den Charakter im Spiel zu programmieren. Diese wird in der Programmiersprache C\# geschrieben, damit sie in der Spieleentwicklungsumgebung ”Unity” als Skript in das vorhandene Projekt eingebunden werden kann. Hierbei muss auf eine intuitive Steuerung geachtet werden, da die Attraktion einer großen Zielgruppe zur Verfügung gestellt werden soll. Die Intuitivität\footnote{Je leichter es ist sich die Bedienung der Steuerung anzueignen, desto höher ist die Intuitivität.} soll durch eine leichte erlernbare Steuerung, sowie eine deutliches visuelles Feedback realisiert werden. Im Projekt vorhanden sind bereits sämtliche Modelle, Animationen, sowie Sounds und Hintergrundmusik, aber auch schon einzelne, von mir früher programmierte Skripte, die sich z.B. um das Benutzerinterface kümmern. Die benötigten Daten für die Steuerung des Charakters werden von einer Trackballmaus zum Computer übertragen und müssen dort in die Bewegung umgesetzt werden. Außerdem muss im Rahmen der Projektarbeit bestimmt werden, wie sich der Charakter in der virtuellen Welt verhält, sowie in welchen Situationen der Spieler das Spiel vorzeitig verlieren kann und ab welchem Zeitpunkt das Spiel gewonnen ist.

\section{Projektziel}
\paragraph{}
Mit dem Projekt soll eine gewisse Hartnäckigkeit, gefolgt von gesteigerter Motivation durch Erfolgserlebnisse bei den Mitarbeitern, sowie Besuchern von Firmenfesten und anderen Events erzielt werden. Der Benutzer wird mit jeder gespielten Runde vor die Aufgabe gestellt, eine scheinbar unerreichbare Hürde zu überwinden. Er wird viele Versuche brauchen, um den Gipfel zu erreichen. Der spielerische Aspekt sorgt unweigerlich dafür, dass der Benutzer leichter mit häufigen Niederlagen umgehen kann, um anschließend den anfangs weit entfernten Berg erneut herauszufordern. Sobald der Spieler am Gipfel angekommen ist, gibt es auditive und visuelle Erfolgsmeldungen. Dazu erscheint eine Anzeige, wie lange der Weg zur Bergspitze gedauert hat, damit der Spieler sich mit anderen messen kann und ein Wettkampfgefühl entsteht.

\section{Projektabgrenzung}
\label{Projektabgrenzung}
\paragraph{}
Im Projekt sind bereits ein Spielehauptcontroller, sowie eine Animations- und Bewegungssteuerung vorhanden.
Der Hauptcontroller sorgt für die Verwaltung der Grundstatus\footnote{Die vier Status sind in aktiv, spielend, gewonnen und verloren eingeteilt.} im Spiel. Außerdem speichert er die wichtigsten Variabeln, wie unter anderem Spieldauer oder die Höhe abweichend vom Fuß des Berges. Es wird lediglich ein Verweis via Assoziation in der Charaktersteuerung eingebunden, damit z.B. die Höhendaten kommuniziert werden können.

\chapter{Projektplanung}
\section{Projektphasen}
\paragraph{}
Für die Umsetzung des Teils des Projekts stehen insgesamt 70 Stunden zur Verfügung. Die Entwicklung wurde vor Beginn des Projekts auf die verschiedene Projektphasen aufgeteilt. In der folgenden Tabelle \tref{tab:Zeit} lässt sich die grobe Zeitplanung ablesen.\\
\input{Tabellen/Zeitplanung}


\section{Ressourcenplanung}
Es werden alle verwendeten Ressourcen, wie Hard- und Software in einer Übersicht im Anhang in \fullref{Abb:Ressourcen} aufgeführt. Um möglichen Aufwand für Software so gering wie möglich zu halten, wurde darauf geachtet kostenfreie, sowie Open Source Software zu benutzen.

\chapter{Analysephase}
\section{Ist-Analyse}
\paragraph{}
In dem Spiel gibt es viele kleine Details, welche über das Einbinden von Scripten und das Platzieren von 3D-Modellen realisiert werden. Dazu gehört zunächst die Spielkarte auf der sich der Charakter bewegt. Diese wurde von anderen Teammitgliedern erstellt, mit 3D-Modellen wie z.B. Bäumen, Sträuchern oder Gesteinsbrocken bestückt und in das Projekt implementiert. Zusätzlich wurden 3D-Modelle von Wolken und Vögeln erstellt, die sich im Kreis um den Hauptberg bewegen\footnote{Die Bewegung wird von einem Script gesteuert.}.
Die Spielfigur namens \q{Sisyfox} gehört zu den schon erstellten 3D-Modellen und wurde ebenfalls schon mit einer vollständigen Animation versehen. Diese Animation hat jedoch nichts mit der eigentlichen Bewegung des Charakters zu tun. Sie zeigt lediglich visuell eine Laufbewegung an, die aber nicht für eine Positionsverschiebung sorgt. 
Wie in \autoref{Projektabgrenzung} \nameref{Projektabgrenzung} schon angedeutet, ist der Hauptcontroller, als einer von vielen Scripten, schon vorhanden. Weitere wichtige Scripte sind die Kamerasteuerung, sämtliche Animationsscripte, eine Höhenmeteranzeige und ein Arduinokommunikationsscript, welcher eine Verbindung zu einer Hardwarekonstruktion namens \q{Arduino\fcitetitle{Arduino}} aufbaut. Letzter sorgt dafür, dass sich relativ zur Höhe auf der sich der Charakter befindet, ein angeschlossener Ventilator stärker dreht und eine Nebelmaschine kurz vor Erreichen des Gipfels anspringt.

\section{Anforderungsanalyse}
\paragraph{}
Um das Spiel zu komplettieren muss also eine Charaktersteuerung geschrieben werden. Diese soll von dem Nutzer kontrolliert werden. Das bedeutet, dass der Nutzer Eingaben tätigt und die Steuerung dafür sorgt, dass es ein visuelles Feedback gibt. Hierbei muss innerhalb der Steuerung auf vorher festgelegte Verlier- und Gewinnbedingungen reagiert und zusätzlich eine möglichst realistische und damit intuitive Bewegung ermöglicht werden. In der Entwurfsphase wird das genauere Vorgehen einschließlich einer Programmarchitekturauswahl hinsichtlich der gestellten Anforderungen erläutert.

\chapter{Entwurfsphase}
\section{Zielplattform}
\paragraph{}
Zur Auswahl standen die IDEs\footnote{eng: integrated development environment, de: Integrierte Entwicklungsumgebung} \q{Unity 3D Engine} und \q{Unreal Engine 4}. Gewählt wurde die Unity Engine, da es in der Unreal Engine mangels grundlegender Vorkenntnisse zu einer deutlich längeren Entwicklungszeit kommen würde. Es müsste zunächst ein großer Teil der Zeit für Einarbeitung aufgewandt werden. 
Ein weiterer Grund ist das sehr einfache und intuitive Einbinden von Gameobjekten\footnote{\q{Gameobjekte} sind die Grundbausteine von jedem Unity Spiel.}) und deren angebundenen Scripten.

\section{Architekturdesign}
\paragraph{}
Für den Architekturaufbau standen das \q{Model-View-Controller-} (MVC) und das \q{Presentation-Abstraction-Control-Muster} (PAC) zur Auswahl.
\paragraph{}
Das MVC Muster (Siehe Schema \fullref{Abb:MVC}) besteht grundsätzlich aus drei Strukturen, die unterschiedliche Ebenen im Programmaufbau darstellen.
Diese unterteilen sich in \q{Modell-}, \q{View-} und \q{Controller-Ebene}. Die Unterteilung dient hierbei dem Zweck, dass jede Ebene flexibel und unabhängig von den Anderen verändert, ersetzt oder erweitert werden kann. 
Das Modell beinhaltet die Daten, die für die Anzeige nötig sind. Über die View-Ebene werden die Daten aus dem Modell dem Benutzer angezeigt und des Weiteren mögliche Benutzereingaben entgegengenommen. Wenn sich Daten im Modell ändern wird im Regelfall die View-Ebene mithilfe eines Beobachters\footnote{Der Beobachter meldet sich bei der View-Ebene, sobald sich Daten im Modell ändern.} benachrichtigt, sodass sich die View aktualisieren kann. Die entgegengenommen Benutzereingaben werden von dem Controller übernommen und verarbeitet. In dem objektorientierten Ansatz führt der Controller Methoden im Modell aus, damit die Aktionen des Benutzers wirksam werden. Außerdem kann der Controller die View direkt manipulieren, um z.B. die angezeigten Eingabemöglichkeiten zu verändern. 
\paragraph{}
Für den anderen Ansatz, in dem man ein System in verschiedenen Einzelteilen erstellt, benötigt man ein Muster, dass jede Aufgabe in einem anderen Teil des System abbildet. Dadurch wird hohe Flexibilität ermöglicht, die sich auch im Wartungsaufwand widerspiegelt.
Im PAC Muster (Siehe Schema \fullref{Abb:PAC}) teilt man das System in zwei Richtungen auf, zunächst in drei Einheiten, die grafische Oberfläche, einer Kommunikationsschnittstelle und einem Datenmodell. Diese Einheiten ähneln dem MVC-Muster.
\paragraph{}
Darüber hinaus teilt sich das Architekturmuster hierarchisch auf sogenannte \q{Agenten} auf.
Diese Agenten werden auf drei Schichten verteilt, auf \textit{Top-Level-}, \textit{Intermediate-Level-} und \textit{Bottom-Level}-Agenten. Den \textit{Top-Level}-Agenten gibt es nur einmal im System, er übernimmt die globalen Aufgaben. Für die \textit{Bottom-Level}-Agenten ist eine möglichst in sich abgeschlossene Aufgabe vorgesehen. Die \textit{Bottom-Level}-Agenten können über implementierte Methoden in den \textit{Intermediate-Level}-Agenten mit dem \textit{Top-Level} kommuniziert.
\paragraph{}
In dem Projekt wird sich für eine einfache Variante des PAC-Musters entschieden. Der schon vorhandenen Hauptcontroller wird als Top-Level-Agent eingestuft und die Charaktersteuerung als eine Mischung aus Intermediate- und Bottom-Level-Agent. Die Steuerung wird über eine einfache Assoziation direkt mit dem Hauptcontroller kommunizieren können. Im nächsten Abschnitt wird ein Entwurf eines Klassendiagrammes erläutert, in dem diese Herangehensweise umgesetzt wird.

\section{Entwurf der Benutzeroberfläche}
\paragraph{}
An der Benutzeroberfläche wird in dem Projekt nichts verändert. Es werden jedoch einige Daten von der Charakter Steuerung an den Hauptcontroller übermittelt, welche auf dem Bildschirm angezeigt werden. Im Anhang befindet sich eine Skizze (Siehe Anhang \fullref{Abb:UISkizze}), sowie ein Anzeigebild aus dem laufendem Spiel (Siehe Anhang \fullref{Abb:UIIngame}), in dem die wichtigsten Anzeigen eingetragen sind. Auf der Skizze befindet sich Punkt \q{A} oben links auf dem Bildschirm lokalisiert. An der Position wird eine weiße Bergsilhouette gezeigt, die sich relativ zur Charakterhöhe am Berg füllt. Die Charakterhöhe wird von der Charaktersteuerung ermittelt und an den Hauptcontroller für die Anzeige der Höhe und der Bergfüllanzeige übergeben. Gleich rechts daneben - Punkt \q{B} - zeigt die vergangene Zeit für den bisherigen Versuch an. In der Mitte des Bildschirms ist eine Höhenanzeige in Metern eingebaut (siehe Punkt \q{C}). Diese erscheint alle 150 Höhenmeter und gibt den derzeitigen Zwischenstand an. Anschließend verschwindet sie wieder. Als letzten Punkt auf der Skizze ist die Charakterposition eingezeichnet.
\paragraph{}
Auf der \fullref{Abb:UIIngame} sind alle auftretenden Benutzerinterface Anzeigen im Spiel dargestellt.

\section{Geschäftslogik}
\paragraph{}
Zunächst werden die Anforderungen an die Charaktersteuerung festgelegt, damit daraus ein Klassendiagramm entstehen kann. Das Klassendiagramm kann im Anhang in \fullref{Abb:KlassendiaMain} eingesehen werden. Die Steuerung muss als Hauptaufgabe die Mausinformationen, sowie dessen Bewegungsrichtung ermitteln und in eine Bewegung der Kugel beim Charakters übersetzen. Um das zu realisieren, muss die aktuelle Mausposition gespeichert werden und im anschließenden Frame\footnote{Ein Frame ist ein angezeigtes Bild während das Spiel läuft. Das Spiel läuft mit ca. 60 Frames pro Sekunde.} der Unterschied zum vorherigen Frame berechnet werden. Aus dieser Bewegung kann ein Richtungsvektor ermittelt werden. Dieser Vektor beinhaltet die genaue Richtung, sowie die Strecke die sich die Maus bewegt hat. Durch die Strecke kann die Steuerung eine Beschleunigung der Kugel berechnen. Ist das geschehen, so kann die Beschleunigung auf die Kugel angewandt werden, damit sie sich in eine Richtung bewegt.
\paragraph{}
Zusätzlich sollen vorher festgelegte Mechanismen überprüfen, in welchen Situationen der Spieler das Spiel gewinnt oder verliert. Dieser Zustand oder auch Status der Spiels wird vom Hauptcontroller verwaltet (Siehe Statemachine Anhang \fullref{Abb:SMStatus}). Der Status geht vom \textit{inaktiv}\footnote{Im inaktiv Status verweilt das Spiel solange, wie es keine Benutzerinteraktion gibt.} Status über in den \textit{laufend} Status, welcher je nach Spielweise in \textit{gewinnen} oder \textit{verlieren} endet. Gewinnen wird der Spieler, wenn er am Gipfel des Bergen angelangt ist und dort in eine Triggerbox\footnote{Ein Trigger ist in dem Fall eine unsichtbare Box, die an ihren Außenseiten eine Kollisionserkennung hat, die sich wiederum bei einem kollidierenden Objekt meldet.} (Siehe auch  \fullref{Abb:GewinnTrigger}) hineinläuft und somit den \textit{gewonnen} Status erreicht. Der Verlier-Mechanismus funktioniert ähnlich. Hierfür wurde festgelegt, dass bei Berührung eines Baumes (Siehe auch \fullref{Abb:BaumTrigger}) oder Felsbrockens das Spiel verloren sein soll. Dafür werden diese ebenfalls mit einem Trigger versehen, der diesmal den \textit{verloren} Status auslöst.
\paragraph{}
Zusätzlich soll der Kugel eine möglichst realistische Physik gegeben werden. Das heißt, dass der Charakter nicht in der Lage sein soll, die Kugel seitlich an einem Abhang entlang zu rollen, ohne dass sie ihm zur Seite weg rollt und er die Runde verliert. Er kann als Reaktion versuchen den Charakter unter die Kugel zu manövrieren, sodass die Steigung vor ihm liegt und nicht seitlich. Dann kann der Charakter die Kugel festhalten. Bei einem seitlichen Steigungswinkel von über 65\cc verliert der Spieler sofort das Spiel. Ist der Winkel kleiner als 65\cc, jedoch größer als 40\cc, dann hat der Spieler 2 Sekunden, um seine Spielfigur zu richten. Wenn der Spieler sich auf einem Hang befindet, der einen Winkel größer 20\cc hat, dann ist die Zeit, die er zum Spielfigur Richten bekommt, zwischen zwei bis vier Sekunden. Das ist abhängig davon, wie weit die Steigung zwischen 20\cc und 40\cc liegt. Es liegt im Anhang die \fullref{Abb:SeitlWinkel} vor, die diese Funktionsweise verbildlicht. Wie angesprochen kann die Spielfigur die Kugel an beliebig steilen Steigungen festhalten, solange sie sich unter\footnote{\q{Unter} bedeutet, dass der Spieler gerade auf die Steigung zuläuft.} der Kugel befindet. Befindet sich der Charakter auf der anderen Seite (\q{Über} der Kugel), dann ist die Kugel ebenfalls bei einem Winkel von 65\cc verloren.
\paragraph{}
Als weitere Funktion der Steuerung soll der Charakter, wenn er durch einen Busch läuft, ausgebremst werden. Hierzu muss für jeden Busch ein weiterer Trigger (Siehe auch \fullref{Abb:BuschTrigger}) hinzugefügt werden.

\section{Maßnahmen zu Qualitätssicherung}
\paragraph{}


\chapter{Implementierungsphase}
\section{Implementierung der Geschäftslogik}
\paragraph{}


\section{Implementierung der Benutzeroberfläche}
\paragraph{}

\chapter{Abnahme- und Einführungsphase}

\section{Abnahme}
\section{Einführung}
\section{Dokumentation}

\chapter{Fazit}
\section{Soll-/Ist-Vergleich}
\section{Lessons Learned}
\section{Ausblick}
